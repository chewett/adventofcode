package net.chewett.adventofcode.aoc2022.problems;

import net.chewett.adventofcode.datastructures.Discrete2DPositionGrid;
import net.chewett.adventofcode.helpers.ProblemLoader;

import java.awt.*;
import java.util.List;

/**
 * --- Day 9: Rope Bridge ---
 * This rope bridge creaks as you walk along it. You aren't sure how old it is, or whether it can even support your
 * weight.
 *
 * It seems to support the Elves just fine, though. The bridge spans a gorge which was carved out by the massive river
 * far below you.
 *
 * You step carefully; as you do, the ropes stretch and twist. You decide to distract yourself by modeling rope
 * physics; maybe you can even figure out where not to step.
 *
 * Consider a rope with a knot at each end; these knots mark the head and the tail of the rope. If the head moves far
 * enough away from the tail, the tail is pulled toward the head.
 *
 * Due to nebulous reasoning involving Planck lengths, you should be able to model the positions of the knots on a
 * two-dimensional grid. Then, by following a hypothetical series of motions (your puzzle input) for the head, you
 * can determine how the tail will move.
 *
 * Due to the aforementioned Planck lengths, the rope must be quite short; in fact, the head (H) and tail (T) must
 * always be touching (diagonally adjacent and even overlapping both count as touching):
 *
 * ....
 * .TH.
 * ....
 *
 * ....
 * .H..
 * ..T.
 * ....
 *
 * ...
 * .H. (H covers T)
 * ...
 * If the head is ever two steps directly up, down, left, or right from the tail, the tail must also move one step in
 * that direction so it remains close enough:
 *
 * .....    .....    .....
 * .TH.. -> .T.H. -> ..TH.
 * .....    .....    .....
 *
 * ...    ...    ...
 * .T.    .T.    ...
 * .H. -> ... -> .T.
 * ...    .H.    .H.
 * ...    ...    ...
 * Otherwise, if the head and tail aren't touching and aren't in the same row or column, the tail always moves one
 * step diagonally to keep up:
 *
 * .....    .....    .....
 * .....    ..H..    ..H..
 * ..H.. -> ..... -> ..T..
 * .T...    .T...    .....
 * .....    .....    .....
 *
 * .....    .....    .....
 * .....    .....    .....
 * ..H.. -> ...H. -> ..TH.
 * .T...    .T...    .....
 * .....    .....    .....
 * You just need to work out where the tail goes as the head follows a series of motions. Assume the head and the tail
 * both start at the same position, overlapping.
 *
 * For example:
 *
 * R 4
 * U 4
 * L 3
 * D 1
 * R 4
 * D 1
 * L 5
 * R 2
 * This series of motions moves the head right four steps, then up four steps, then left three steps, then down one
 * step, and so on. After each step, you'll need to update the position of the tail if the step means the head is no
 * longer adjacent to the tail. Visually, these motions occur as follows (s marks the starting position as a reference
 * point):
 *
 * == Initial State ==
 *
 * ......
 * ......
 * ......
 * ......
 * H.....  (H covers T, s)
 *
 * == R 4 ==
 *
 * ......
 * ......
 * ......
 * ......
 * TH....  (T covers s)
 *
 * ......
 * ......
 * ......
 * ......
 * sTH...
 *
 * ......
 * ......
 * ......
 * ......
 * s.TH..
 *
 * ......
 * ......
 * ......
 * ......
 * s..TH.
 *
 * == U 4 ==
 *
 * ......
 * ......
 * ......
 * ....H.
 * s..T..
 *
 * ......
 * ......
 * ....H.
 * ....T.
 * s.....
 *
 * ......
 * ....H.
 * ....T.
 * ......
 * s.....
 *
 * ....H.
 * ....T.
 * ......
 * ......
 * s.....
 *
 * == L 3 ==
 *
 * ...H..
 * ....T.
 * ......
 * ......
 * s.....
 *
 * ..HT..
 * ......
 * ......
 * ......
 * s.....
 *
 * .HT...
 * ......
 * ......
 * ......
 * s.....
 *
 * == D 1 ==
 *
 * ..T...
 * .H....
 * ......
 * ......
 * s.....
 *
 * == R 4 ==
 *
 * ..T...
 * ..H...
 * ......
 * ......
 * s.....
 *
 * ..T...
 * ...H..
 * ......
 * ......
 * s.....
 *
 * ......
 * ...TH.
 * ......
 * ......
 * s.....
 *
 * ......
 * ....TH
 * ......
 * ......
 * s.....
 *
 * == D 1 ==
 *
 * ......
 * ....T.
 * .....H
 * ......
 * s.....
 *
 * == L 5 ==
 *
 * ......
 * ....T.
 * ....H.
 * ......
 * s.....
 *
 * ......
 * ....T.
 * ...H..
 * ......
 * s.....
 *
 * ......
 * ......
 * ..HT..
 * ......
 * s.....
 *
 * ......
 * ......
 * .HT...
 * ......
 * s.....
 *
 * ......
 * ......
 * HT....
 * ......
 * s.....
 *
 * == R 2 ==
 *
 * ......
 * ......
 * .H....  (H covers T)
 * ......
 * s.....
 *
 * ......
 * ......
 * .TH...
 * ......
 * s.....
 * After simulating the rope, you can count up all of the positions the tail visited at least once. In this diagram,
 * s again marks the starting position (which the tail also visited) and # marks other positions the tail visited:
 *
 * ..##..
 * ...##.
 * .####.
 * ....#.
 * s###..
 * So, there are 13 positions the tail visited at least once.
 *
 * Simulate your complete hypothetical series of motions. How many positions does the tail of the rope visit at least
 * once?
 *
 * --- Part Two ---
 * A rope snaps! Suddenly, the river is getting a lot closer than you remember. The bridge is still there, but some
 * of the ropes that broke are now whipping toward you as you fall through the air!
 *
 * The ropes are moving too quickly to grab; you only have a few seconds to choose how to arch your body to avoid
 * being hit. Fortunately, your simulation can be extended to support longer ropes.
 *
 * Rather than two knots, you now must simulate a rope consisting of ten knots. One knot is still the head of the rope
 * and moves according to the series of motions. Each knot further down the rope follows the knot in front of it using
 * the same rules as before.
 *
 * Using the same series of motions as the above example, but with the knots marked H, 1, 2, ..., 9, the motions now
 * occur as follows:
 *
 * == Initial State ==
 *
 * ......
 * ......
 * ......
 * ......
 * H.....  (H covers 1, 2, 3, 4, 5, 6, 7, 8, 9, s)
 *
 * == R 4 ==
 *
 * ......
 * ......
 * ......
 * ......
 * 1H....  (1 covers 2, 3, 4, 5, 6, 7, 8, 9, s)
 *
 * ......
 * ......
 * ......
 * ......
 * 21H...  (2 covers 3, 4, 5, 6, 7, 8, 9, s)
 *
 * ......
 * ......
 * ......
 * ......
 * 321H..  (3 covers 4, 5, 6, 7, 8, 9, s)
 *
 * ......
 * ......
 * ......
 * ......
 * 4321H.  (4 covers 5, 6, 7, 8, 9, s)
 *
 * == U 4 ==
 *
 * ......
 * ......
 * ......
 * ....H.
 * 4321..  (4 covers 5, 6, 7, 8, 9, s)
 *
 * ......
 * ......
 * ....H.
 * .4321.
 * 5.....  (5 covers 6, 7, 8, 9, s)
 *
 * ......
 * ....H.
 * ....1.
 * .432..
 * 5.....  (5 covers 6, 7, 8, 9, s)
 *
 * ....H.
 * ....1.
 * ..432.
 * .5....
 * 6.....  (6 covers 7, 8, 9, s)
 *
 * == L 3 ==
 *
 * ...H..
 * ....1.
 * ..432.
 * .5....
 * 6.....  (6 covers 7, 8, 9, s)
 *
 * ..H1..
 * ...2..
 * ..43..
 * .5....
 * 6.....  (6 covers 7, 8, 9, s)
 *
 * .H1...
 * ...2..
 * ..43..
 * .5....
 * 6.....  (6 covers 7, 8, 9, s)
 *
 * == D 1 ==
 *
 * ..1...
 * .H.2..
 * ..43..
 * .5....
 * 6.....  (6 covers 7, 8, 9, s)
 *
 * == R 4 ==
 *
 * ..1...
 * ..H2..
 * ..43..
 * .5....
 * 6.....  (6 covers 7, 8, 9, s)
 *
 * ..1...
 * ...H..  (H covers 2)
 * ..43..
 * .5....
 * 6.....  (6 covers 7, 8, 9, s)
 *
 * ......
 * ...1H.  (1 covers 2)
 * ..43..
 * .5....
 * 6.....  (6 covers 7, 8, 9, s)
 *
 * ......
 * ...21H
 * ..43..
 * .5....
 * 6.....  (6 covers 7, 8, 9, s)
 *
 * == D 1 ==
 *
 * ......
 * ...21.
 * ..43.H
 * .5....
 * 6.....  (6 covers 7, 8, 9, s)
 *
 * == L 5 ==
 *
 * ......
 * ...21.
 * ..43H.
 * .5....
 * 6.....  (6 covers 7, 8, 9, s)
 *
 * ......
 * ...21.
 * ..4H..  (H covers 3)
 * .5....
 * 6.....  (6 covers 7, 8, 9, s)
 *
 * ......
 * ...2..
 * ..H1..  (H covers 4; 1 covers 3)
 * .5....
 * 6.....  (6 covers 7, 8, 9, s)
 *
 * ......
 * ...2..
 * .H13..  (1 covers 4)
 * .5....
 * 6.....  (6 covers 7, 8, 9, s)
 *
 * ......
 * ......
 * H123..  (2 covers 4)
 * .5....
 * 6.....  (6 covers 7, 8, 9, s)
 *
 * == R 2 ==
 *
 * ......
 * ......
 * .H23..  (H covers 1; 2 covers 4)
 * .5....
 * 6.....  (6 covers 7, 8, 9, s)
 *
 * ......
 * ......
 * .1H3..  (H covers 2, 4)
 * .5....
 * 6.....  (6 covers 7, 8, 9, s)
 * Now, you need to keep track of the positions the new tail, 9, visits. In this example, the tail never moves,
 * and so it only visits 1 position. However, be careful: more types of motion are possible than before, so you might
 * want to visually compare your simulated rope to the one above.
 *
 * Here's a larger example:
 *
 * R 5
 * U 8
 * L 8
 * D 3
 * R 17
 * D 10
 * L 25
 * U 20
 * These motions occur as follows (individual steps are not shown):
 *
 * == Initial State ==
 *
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ...........H..............  (H covers 1, 2, 3, 4, 5, 6, 7, 8, 9, s)
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 *
 * == R 5 ==
 *
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ...........54321H.........  (5 covers 6, 7, 8, 9, s)
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 *
 * == U 8 ==
 *
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ................H.........
 * ................1.........
 * ................2.........
 * ................3.........
 * ...............54.........
 * ..............6...........
 * .............7............
 * ............8.............
 * ...........9..............  (9 covers s)
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 *
 * == L 8 ==
 *
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ........H1234.............
 * ............5.............
 * ............6.............
 * ............7.............
 * ............8.............
 * ............9.............
 * ..........................
 * ..........................
 * ...........s..............
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 *
 * == D 3 ==
 *
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * .........2345.............
 * ........1...6.............
 * ........H...7.............
 * ............8.............
 * ............9.............
 * ..........................
 * ..........................
 * ...........s..............
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 *
 * == R 17 ==
 *
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ................987654321H
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ...........s..............
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 *
 * == D 10 ==
 *
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ...........s.........98765
 * .........................4
 * .........................3
 * .........................2
 * .........................1
 * .........................H
 *
 * == L 25 ==
 *
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ...........s..............
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * H123456789................
 *
 * == U 20 ==
 *
 * H.........................
 * 1.........................
 * 2.........................
 * 3.........................
 * 4.........................
 * 5.........................
 * 6.........................
 * 7.........................
 * 8.........................
 * 9.........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ...........s..............
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 *
 * Now, the tail (9) visits 36 positions (including s) at least once:
 *
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * ..........................
 * #.........................
 * #.............###.........
 * #............#...#........
 * .#..........#.....#.......
 * ..#..........#.....#......
 * ...#........#.......#.....
 * ....#......s.........#....
 * .....#..............#.....
 * ......#............#......
 * .......#..........#.......
 * ........#........#........
 * .........########.........
 * Simulate your complete series of motions on a larger rope with ten knots. How many positions does the tail of the
 * rope visit at least once?
 */
public class Day9 {

    /**
     * Simple manhattan distance function
     * @param p1 Point one to compare against
     * @param p2 Point two to compare against
     * @return Manhattan distance between the points
     */
    public int getManhattanDistance(Point p1, Point p2) {
        return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);
    }

    /**
     * Given a head position and a tail position (that needs to follow the head according to the rules)
     * Either don't move the tail, or move it according to the movement rules
     * @param headPoint Head position to follow
     * @param tailPoint Tail position that must be moved or kept in the same location
     */
    public void moveToNewLocation(Point headPoint, Point tailPoint) {
        // Handle the case where the points are on the same X axis
        if (tailPoint.x == headPoint.x) {
            if (tailPoint.y > headPoint.y) {
                int diff = tailPoint.y - headPoint.y;
                //The diff here will always be one or two, if its two it needs to move closer
                if (diff == 2) {
                    tailPoint.y--;
                }
            } else if (tailPoint.y < headPoint.y) {
                int diff = headPoint.y - tailPoint.y;
                //The diff here will always be one or two, if its two it needs to move closer
                if (diff == 2) {
                    tailPoint.y++;
                }
            }

        // Handle the case where the points are on the same X axis
        } else if (tailPoint.y == headPoint.y) {
            if (tailPoint.x > headPoint.x) {
                int diff = tailPoint.x - headPoint.x;
                //The diff here will always be one or two, if its two it needs to move closer
                if (diff == 2) {
                    tailPoint.x--;
                }
            } else if (tailPoint.x < headPoint.x) {
                int diff = headPoint.x - tailPoint.x;
                //The diff here will always be one or two, if its two it needs to move closer
                if (diff == 2) {
                    tailPoint.x++;
                }
            }
        } else {
            // This means the tail might need to be moving diagonally
            int manhattanDistance = getManhattanDistance(headPoint, tailPoint);
            //3 means it's an L shape and we need to move closer to it
            if (manhattanDistance == 3) {
                int yDistance = tailPoint.y - headPoint.y;
                int xDistance = tailPoint.x - headPoint.x;

                if (yDistance == 2) {
                    tailPoint.y--;
                    tailPoint.x -= xDistance;
                } else if (yDistance == -2) {
                    tailPoint.y++;
                    tailPoint.x -= xDistance;
                } else if (xDistance == 2) {
                    tailPoint.x--;
                    tailPoint.y -= yDistance;
                } else if (xDistance == -2) {
                    tailPoint.x++;
                    tailPoint.y -= yDistance;
                }

            //This is the extension case for part two where you might have
            // ..H
            // ...
            // T..
            // so you need to move it diagonally towards it
            }else if(manhattanDistance == 4) {
                int yDistance = tailPoint.y - headPoint.y;
                int xDistance = tailPoint.x - headPoint.x;

                if(yDistance == 2) {
                    tailPoint.y--;
                }else if(yDistance == -2) {
                    tailPoint.y++;
                }
                if(xDistance == 2) {
                    tailPoint.x--;
                }else if(xDistance == -2) {
                    tailPoint.x++;
                }
            }

        }
    }

    /**
     * Perform the movements with a single head and tail and work out where the tail visits
     * @param movements List of movements to perform
     * @return Number of locations the tail visits
     */
    public long solvePartOne(List<String> movements) {
        Discrete2DPositionGrid<Character> grid = new Discrete2DPositionGrid<>('.');
        Point head = new Point(0, 0);
        Point tail = new Point(0, 0);

        grid.setValueAtPosition(tail, '#');
        for(String move : movements) {
            String[] moveParts = move.split(" ");
            int moveNumberToRepeat = Integer.parseInt(moveParts[1]);
            //Do the moves one by one to make it much easier to handle and manage
            for (int moveIndex = 0; moveIndex < moveNumberToRepeat; moveIndex++) {
                int moveNumber = 1;
                String moveLocation = moveParts[0];

                //Move it
                if (moveLocation.equals("D")) {
                    head.y -= moveNumber;
                } else if (moveLocation.equals("U")) {
                    head.y += moveNumber;
                } else if (moveLocation.equals("L")) {
                    head.x -= moveNumber;
                } else {
                    head.x += moveNumber;
                }

                //Now work out if the tail should be moved, if so then it will move
                this.moveToNewLocation(head, tail);
                grid.setValueAtPosition(tail, '#');
            }
        }

        return grid.countInstancesOfValue('#');
    }

    public long solvePartTwo(List<String> movements) {
        Discrete2DPositionGrid<Character> grid = new Discrete2DPositionGrid<>('.');
        //Here we define many head -> tail elements
        Point head = new Point(0, 0);
        Point knot1 = new Point(0, 0);
        Point knot2 = new Point(0, 0);
        Point knot3 = new Point(0, 0);
        Point knot4 = new Point(0, 0);
        Point knot5 = new Point(0, 0);
        Point knot6 = new Point(0, 0);
        Point knot7 = new Point(0, 0);
        Point knot8 = new Point(0, 0);
        Point tail = new Point(0, 0);

        grid.setValueAtPosition(tail, '#');
        for(String move : movements) {
            String[] moveParts = move.split(" ");
            int moveNumberToRepeat = Integer.parseInt(moveParts[1]);
            //Do the moves one by one to make it much easier to handle and manage
            for(int moveIndex = 0; moveIndex < moveNumberToRepeat; moveIndex++) {
                int moveNumber = 1;
                String moveLocation = moveParts[0];

                //Move it
                if (moveLocation.equals("D")) {
                    head.y -= moveNumber;
                } else if (moveLocation.equals("U")) {
                    head.y += moveNumber;
                } else if (moveLocation.equals("L")) {
                    head.x -= moveNumber;
                } else {
                    head.x += moveNumber;
                }

                //Here is the same except you need to chain the movements and checking
                this.moveToNewLocation(head, knot1);
                this.moveToNewLocation(knot1, knot2);
                this.moveToNewLocation(knot2, knot3);
                this.moveToNewLocation(knot3, knot4);
                this.moveToNewLocation(knot4, knot5);
                this.moveToNewLocation(knot5, knot6);
                this.moveToNewLocation(knot6, knot7);
                this.moveToNewLocation(knot7, knot8);
                this.moveToNewLocation(knot8, tail);

                grid.setValueAtPosition(tail, '#');
            }

        }

        return grid.countInstancesOfValue('#');
    }

    public static void main(String[] args) {
        List<String> movements = ProblemLoader.loadProblemIntoStringArray(2022, 9);

        Day9 d = new Day9();
        long partOne = d.solvePartOne(movements);
        System.out.println("The number of locations that the tail visits is " + partOne);

        long partTwo = d.solvePartTwo(movements);
        System.out.println("The number of locations the longer knot tail visits is " + partTwo);
    }



}